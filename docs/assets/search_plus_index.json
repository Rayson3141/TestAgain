{"/jekyll/2022-11-24-git_commit.html": {
    "title": "Git - Commit message 格式",
    "keywords": "github tool Jekyll",
    "url": "/jekyll/2022-11-24-git_commit.html",
    "body": "說明 Git 提交時應注意的 Commit message format，建立良好的規範才能有效的合作 做 issue 的時候不應該一次 Commit 所有變動！應該獨立每個 Commit 不同意義的異動，這樣才能使 Commit 快速閱讀與程式碼間的關係。 每次 Commit 都是針對異動做說明，Why &amp; What。 每次 Commit 加上 issue 編號，方便追蹤後續問題。 Commit Message format： Header: type: 代表 commit 的類別：feat, fix, docs, style, refactor, test, chore，必要欄位。 scope 代表 commit 影響的範圍，例如資料庫、控制層、模板層等等，視專案不同而不同，為可選欄位。 subject 代表此 commit 的簡短描述，不要超過 50 個字元，結尾不要加句號，為必要欄位。 Body: Body 部份是對本次 Commit 的詳細描述，可以分成多行，每一行不要超過 72 個字元。 說明程式碼變動的項目與原因，還有與先前行為的對比。 Footer: 填寫任務編號（如果有的話）. BREAKING CHANGE（可忽略），記錄不兼容的變動，以 BREAKING CHANGE: 開頭，後面是對變動的描述、 以及變動原因和遷移方法。 type 需規範好有哪些類別（如下）： feat: 新增/修改功能 (feature)。 fix: 修補 bug (bug fix)。 docs: 文件 (documentation)。 style: 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。 refactor: 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。 perf: 改善效能 (A code change that improves performance)。 test: 增加測試 (when adding missing tests)。 chore: 建構程序或輔助工具的變動 (maintain)。 revert: 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。 Commit message example: 一個簡單的 feat 範例 #Feat Example feat: message 信件通知功能 因應新需求做調整： 通知和 message 都要寄發每日信件， 通知和 message 都用放在同一封信裡面就好， 不然信件太多可能也不會有人想去看。 調整項目： 1. mail_template.php，新增 message 區塊。 2. Send_today_notify_mail.php，新增 取得每日 Message 邏輯。 3. Message_model_api.php，新增 $where 參數，以便取得每日訊息。 4. Message_api.php、Message_group_user_model_api.php，新增 *取得訊息使用者* 邏輯，以便撈取每日訊息。 issue #863 feat: 表單統計，多顯示計畫名稱欄位 因應需求做調整： 1. 列表資訊多加「計畫名稱」欄位，以利後續匯出資料處理。 調整項目： 1. Assessment_form.php，匯出表單統計時，新增訓練計畫名欄位。 2. customize.php，表單統計查詢時，多顯示訓練計畫名欄位。 3. Complex_assessment_form_api.php、Complex_assessment_form_model_api.php： - 取得表單統計資料時，多取得計畫名稱。 issue #1200 NOTE 只會寫程式只能代表你是一個會寫程式的人，能跟一群人一起寫程式才是一個好的工程師。"
  },"/jekyll/2022-11-22-ai_ml_introduction.html": {
    "title": "AI - Machine Learning",
    "keywords": "ai algorithm Jekyll",
    "url": "/jekyll/2022-11-22-ai_ml_introduction.html",
    "body": "Training phase 黑盒子，x進y出。 Prediction phase 如一公式，y=ax+b var, a &amp; b 如何求解，當 a 和 b 的值被估計出來即為白盒子，即可做 Predict. train的基本概念。 instamce, record, case, observation, row. attribute, field, cloumn. -0.006 = a 10.0314 = b Root mean squared error 1.0317. iris three-type iris. sepal 花萼 petal 花瓣"
  },"/jekyll/2022-11-08-ai_csp.html": {
    "title": "AI - Constraint Satisfaction Problem",
    "keywords": "ai algorithm Jekyll",
    "url": "/jekyll/2022-11-08-ai_csp.html",
    "body": "Introduction to Artificial Intelligence Week 6 Notes Constraint Satisfaction Problem 約束滿足問題其定義為一組物件，而這些物件需要滿足一定的限制或條件，而這個問題可能有很多的解。CSP 問題經常表現出高複雜性，需要結合啟發式搜尋和搜尋方法來在一個合理的時間內解決問題。 CSP related Linear programming Nonlinear progaramming Numerical analysis CSP application Operations research Network flows optimization problems CSP Define CSP定義一個3-tuple(X, D, C), 其中 X = {X1, …, Xn} Finite set of variables. D = {D1, …, Dn} Nonempty domain of possible values for each variable. C = {C1, …, Cn} Finite set of constraints, Each constraint Ci limits the values that variables can take. Example (Map coloring to CSP) 我們將各區域定義成變數(Variables) Variables : V={WA,NT,Q,NSW,V,SA,T} 每個變數的值域(Domains) Domains : Di={red,green,blue} 將值賦予變數時的限制(Constraints)相鄰區域必須不同顏色, WA≠NT (WA,NT)={(red,green),(red,blue),(green,red),…}"
  },"/jekyll/2022-11-07-network_urat.html": {
    "title": "Notes - UART",
    "keywords": "communication protocol Jekyll",
    "url": "/jekyll/2022-11-07-network_urat.html",
    "body": "修網路實作的時候，給學弟妹講解 URAT 跟怎麼在 Arduino 上實作準備的一些教材 How to transfer data between two computers? 5 Volts logic Signal on transmission medium Metal : Square wave &amp; Sine ware Optical fiber : Light square ware Wireless : Electromagnetic waves 5伏邏輯，怎麼傳遞資料？不同材料的波。 The Universal Asynchronous Receiver/Transmitter (UART) In a world where technology can become obsolete very quickly Still enjoys immense popularity. UART這種簡單的通訊方式已經存在了幾十年，依然廣受歡迎。 Asynchronous communication 異步通訊，所代表的是通訊中兩個byte之間的空隙是不固定的，而一個byte中的bit間隔是固定的。 Capabilities and Characteristics a basic UART system provides robust, moderate-speed, full-duplex communication with only three signals: Tx (transmitted serial data), Rx (received serial data), and ground. 一個基本收送的UART傳輸，僅需要三個端口Tx, Rx, GND。 但在這之前的前提是Rx, Tx, 在相同的數據傳輸頻率。 Key Terms Start bit: The first bit of a one-byte UART transmission. It indicates that the data line is leaving its idle state. The idle state is typically logic high, so the start bit is logic low. The start bit is an overhead bit; this means that it facilitates communication between receiver and transmitter but does not transfer meaningful data. Stop bit: The last bit of a one-byte UART transmission. Its logic level is the same as the signal’s idle state, i.e., logic high. This is another overhead bit. Start bit代表空閒的結束，Srart bit僅代表開始，不具實際數據。 Stop bit代表傳輸結束，電位拉高等待下一次 Start。 Baud rate: The approximate rate (in bits per second, or bps) at which data can be transferred. Example : 9600-baud system，即代表 1 bit 需要 1/(9600 bps) ≈ 104.2 µs，注意 不是實際上每秒傳送 9600 資料，實際上有開銷bit的消耗。 Parity bi: An error-detection bit added to the end of the byte. Odd or Even 如果要設定校正位，就多傳送一個Bit，並預先設計好Odd or Even。 如今天要傳送 00001110 而 even 即 校正為 1 這樣就會有偶數個 1。 Synchronizing and Sampling the UART interface does not use a clock signal to synchronize the Tx and Rx devices. So how does the receiver know when to sample the transmitter’s data signal? 接收器的clock完全獨立於發送器clock。 Conclusion 所以當今天要設計一個UART單方向傳輸，僅用一條線就可以完成。 可以想像接收端的狀態，用程式的表示方式會不會是以迴圈進行，當接到0時， 以預設的頻率收接下來的 8 bit，當電位拉高代表一次傳送的結束。等待下次開始。 Reference Back to Basics: The Universal Asynchronous Receiver/Transmitter (UART)"
  },"/jekyll/2022-11-05-linux_cmd.html": {
    "title": "Notes - Linux common command",
    "keywords": "linux tool Jekyll",
    "url": "/jekyll/2022-11-05-linux_cmd.html",
    "body": "Notes to Linux Common Commands vcgencmd 如果要查詢硬體目前的時脈頻率，可以使用 measure_clock 參數： vcgencmd measure_clock &lt;clock&gt; 其中的 &lt;clock&gt; 是指定要查詢的硬體，可用的選項有 arm、 core、 h264、 isp、 v3d、 uart、pwm、 emmc、 pixel、 vec、 hdmi、 dpi。 如果要查詢 CPU 的時脈頻率（也就是速度），可以執行 vcgencmd measure_clock arm 輸出為 frequency(45)=700000000 如果想查詢所有的硬體時脈頻率，可以使用簡單的 shell 指令稿： for src in arm core h264 isp v3d uart pwm emmc pixel vec hdmi dpi ; do \\ echo -e \"$src:\\t$(vcgencmd measure_clock $src)\" ; \\ done 輸出為 arm: frequency(45)=700000000 core: frequency(1)=250000000 h264: frequency(28)=250000000 isp: frequency(42)=250000000 v3d: frequency(43)=250000000 uart: frequency(22)=3000000 pwm: frequency(25)=0 emmc: frequency(47)=250000000 pixel: frequency(29)=108000000 vec: frequency(10)=0 hdmi: frequency(9)=163682000 dpi: frequency(4)=0 電壓（voltage） 如果要查詢硬體目前的工作電壓，可以使用 measure_volts 參數： vcgencmd measure_volts &lt;id&gt; 其中 &lt;id&gt; 是指定要查詢的硬體，可用的選項有 core、 sdram_c、 sdram_i、 sdram_p。如果沒有指定 &lt;id&gt;，則預設為 core： vcgencmd measure_volts 輸出為 volt=1.200V 查詢所有工作電壓的 shell 指令稿： for id in core sdram_c sdram_i sdram_p ; do \\ echo -e \"$id:\\t$(vcgencmd measure_volts $id)\" ; \\ done 輸出為 core: volt=1.200V sdram_c: volt=1.200V sdram_i: volt=1.200V sdram_p: volt=1.225V 溫度（temperature） 如果要查詢 BCM2835 SoC 目前的溫度，可以使用 measure_temp 參數： vcgencmd measure_temp 輸出為 temp=43.3’C Codec 若要查詢特定的 codec 有沒有啟用，可以使用 codec_enabled 參數： vcgencmd codec_enabled &lt;codec&gt; 其中 &lt;codec&gt; 是指定要查詢的 codec，可用的選項有：H264、 MPG2、 WVC1、 MPG4、 MJPG、 WMV9。 查詢所有 codec 的指令稿： for codec in H264 MPG2 WVC1 MPG4 MJPG WMV9 ; do \\ echo -e \"$codec:\\t$(vcgencmd codec_enabled $codec)\" ; \\ done 輸出為： H264: H264=enabled MPG2: MPG2=disabled WVC1: WVC1=disabled MPG4: MPG4=enabled MJPG: MJPG=enabled WMV9: WMV9=disabled 設定值（configurations） get_config 參數可以列出目前系統中所有被設定的參數值： vcgencmd get_config [config|int|str] 最後一個參數可用來指定要查詢的設定值名稱或是類型，例如查詢 temp_limit 的數值可以執行： vcgencmd get_config temp_limit 輸出為 temp_limit=85 查詢所有數值資料的設定值可用 vcgencmd get_config int 輸出為 hdmi_force_hotplug=1 disable_overscan=1 overscan_left=24 overscan_right=24 overscan_top=16 overscan_bottom=16 program_serial_random=1 config_hdmi_boost=4 emmc_pll_core=1 hdmi_force_cec_address=65535 framebuffer_ignore_alpha=1 framebuffer_swap=1 disable_splash=1 temp_limit=85 force_pwm_open=1 pause_burst_frames=1 second_boot=1 avoid_fix_ts=1 記憶體配置 Raspberry Pi 的 CPU 與 GPU 是共用同同一個記憶體的，get_mem 參數可以查詢目前記憶體的配置狀態。查詢配置給 CPU 的記憶體大小： vcgencmd get_mem arm 輸出為 arm=448M 查詢配置給 GPU 的記憶體大小： vcgencmd get_mem gpu 輸出為 gpu=64M 韌體版本（firmware version） 查詢韌體版本可以使用 vcgencmd version 輸出為 Dec 19 2014 18:44:06 Copyright (c) 2012 Broadcom version 5abd572e2ed1811283443387af09377b95501c50 (clean) (release) OTP 記憶體 若要查詢 SoC 裡面 OTP（one time programmable）記憶體的內容，可以使用 otp_dump： vcgencmd otp_dump 其中 28 與 30 代表硬體序號（serial）與修訂版（revision）的版本號碼，/proc/cpuinfo 中所顯示的序號與修訂版本號碼就是從這裡取得的，而 Model B/B+ 的網路卡 MAC 卡號也是根據硬體序號來產生的。 查看 vcgencmd 所有可用的參數 如果要查看 vcgencmd 指令所有可用的參數，可以執行 vcgencmd commands 輸出會類似這樣： commands=”vcos, ap_output_control, ap_output_post_processing, vchi_test_init, vchi_test_exit, pm_set_policy, pm_get_status, pm_show_stats, pm_start_logging, pm_stop_logging, version, commands, set_vll_dir, led_control, set_backlight, set_logging, get_lcd_info, set_bus_arbiter_mode, cache_flush, otp_dump, test_result, codec_enabled, get_camera, get_mem, measure_clock, measure_volts, scaling_kernel, measure_temp, get_config, hdmi_ntsc_freqs, hdmi_adjust_clock, hdmi_status_show, hvs_update_fields, pwm_speedup, force_audio, hdmi_stream_channels, hdmi_channel_map, display_power, read_ring_osc, memtest, get_rsts, render_bar, disk_notify, inuse_notify, sus_suspend, sus_status, sus_is_enabled, sus_stop_test_thread, egl_platform_switch, mem_validate, mem_oom, mem_reloc_stats, file, vctest_memmap, vctest_start, vctest_stop, vctest_set, vctest_get” 這些就是所有可以使用的參數，這些參數會因為韌體版本不同而有差異。 vboxmanage Virtual box指令操作 手動相關指令說明: 新建一個名為「New VM」的虛擬機器 VBoxManage createvm -name 「New VM」 -register 設定「New VM」的記憶體是128MB並開啟acpi 設定第一開機碟為dvd 以及新增一個網路介面 VBoxManage modifyvm 「New VM」 -memory 「128MB」 -acpi on -boot1 dvd -nic1 intnet 建立一個虛擬硬碟名為「newhd.vdi」 大小為 4000MB VBoxManage createvdi -filename 「newhd.vdi」 -size 4000 -register 將「New VM」的 hda 設定為「newhd.vdi」虛擬磁碟 VBoxManage modifyvm 「New VM」 -hda 「newhd.vdi」 將在\"/home/file/iso.iso\"的ISO映像檔 設定到 名為 dvd的光碟映像檔庫 VBoxManage registerimage dvd /home/file/iso.iso 設定名為「New VM」的 dvd裝置為 /home/file/iso.iso VBoxManage modifyvm 「New VM」 -dvd /home/file/iso.iso 設定「New VM」所使用的 VRDP 的連接Port為 3390 VBoxManage modifyvm 「New VM」 -vrdpport 3390 啟動 VRDP VBoxVRDP -startvm 「New VM」 ----- List function 查詢目前vbox上有設定多少個vm vboxmanage list vms 查看支援的 OS Type vboxmanage list ostypes 查看運行中的 VM vboxmanage list runningvms 其它可以list的指令 vboxmanage list hostdvds vboxmanage list hostinfo vboxmanage list hddbackends vboxmanage list systemproperties vboxmanage list dhcpservers vboxmanage list hdds vboxmanage list dvds 指令啟動vm VBoxManage startvm \"VM name\" --type headless (用背景啟動，不加上--type headless參數可能會有錯誤!!) wifi config $ sudo vim /etc/netplan/50-cloud-init.yaml # This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init's # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network: ethernets: eth0: dhcp4: true optional: true version: 2 wifis: wl0: optional: true access-points: \"SSID-NAME-HERE\": password: \"PASSWORD-HERE\" dhcp4: true"
  },"/jekyll/2022-11-05-docker_jekyll.html": {
    "title": "使用 Jekyll | Docker 建立 Github Pages",
    "keywords": "github jekyll tool Jekyll",
    "url": "/jekyll/2022-11-05-docker_jekyll.html",
    "body": "說明如何使用 Jekyll docker image 在不用熟悉 Ruby 與相關套件管理下，生成靜態文件。 之前就想找一個能用 Markdown 寫筆記的地方，過去都是寫在 Github 的 Repositories 裡面但是檔案一多起來想整理也不方便，那就自己寫個 Blog 當作紀錄， 剛好就趁這個機會把這次的內容當作第一篇紀錄。 Jekyll 是一個用 Ruby 寫的簡單靜態網頁生成器，但是目前我幾乎都是用 Lab 的電腦做事，平時也是遠端到上面，所以很直覺的就想用 Docker 來處理環境， 之後跑腳本把生成好的文件在推上 Github 就可以做好一次更新了。 Required: Docker image Jekyll/Jekyll Html, Javascript, CSS 剛開始就先找個模板來用，Jekyll themes上就有很多可以用的模板來用，像我用的就是使用 GitBook 風格的模板，同時有搜尋功能之後文章的找尋也會比較方便。 找到模板之後去把他 forks 到自己的儲存庫，clone 下來就可以開始修改了。 Docker Jekyll Jekyll 官方有一個 Docker image 所以拉這個 image 就可以了，裡面 Readme 教學寫得還蠻詳細的，只要把模板 volume 到 container 裡面就可以執行 Jekyll 生成。第一次運行安裝套件等等會花一點時間，之後啟動容器速度就快很多了。 之後再簡單寫個 bash script 這樣一個能快速生成的 Jekyll 環境就搭建完成了。 jekyll build 直接生成網頁 jekyll serve 生成網頁後運行在 localhost:4000 docker run \\ -v $WD:/srv/jekyll:z \\ -v /etc/localtime:/etc/localtime:ro\\ -p 4000:4000 \\ --name jekyll \\ -it jekyll/jekyll \\ jekyll serve 2&gt; /dev/null || docker start jekyll &amp;&amp; docker attach jekyll; Customize 之後就等文件生成好，同時記得設定 Github pages publishing source, 把發布源改到生成的目錄。這樣 github.io 的內容就直接指向這個目錄。然後就是一些自定義的小修改，這裡只要會一點 Js, Html 就可以搞定。 像我用的模板本來是舊的 post 優先，稍微改排序，預設字體，加入時間註記，這樣一個簡單的靜態網頁就完成了。 Change default font size: gitbook-plugin-fontsettings \"pluginsConfig\": { \"fontsettings\": { \"size\": 1, } } Add date in post: _layout/post.html change sort method: _includes/toc-date.htnl NOTE 之後想到要修改的再更新吧，可能加入留言系統、標籤之類的，目前這樣的靜態網頁我就很滿意了。"
  }}
